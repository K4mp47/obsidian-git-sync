- Memoria secondaria spesso è un **Collo di bottiglia**
- Il loro miglioramento di prestazioni aumenta in modo significativo le **prestazioni dell'intero sistema**
- Soluzioni sia **sw** sia **hw**
- Ricordiamo che le periferiche hanno ognuna la sua velocità per il trasferimento dei dati
- ![[Pasted image 20240113104612.png]]
- La **comunicazione** tra CPU e dispositivi I/O avviene tramite
	- **Registri di controllo** a cui è assegnata una porta I/O
	- **I/O mappato in memoria**
		- Ad ogni registro è assegnato un unico indirizzo di memoria, al quale non è assegnata memoria
		- Vantaggi
			- Protezione semplice
			- Driver scritti in linguaggi diversi e non asm
			- Le istruzioni possono fare riferimento diretto ai registri di controllo
		- Svantaggi
			- Non posso usare la cache
			- Bus separati per ogni dispositivo, potrebbero non vedere tutti gli indirizzi spediti sui bus
		- ![[Pasted image 20240113105216.png]]
	- **Ibrido**
		- Due spazi, un buffer per i dati I/O mappati in memoria e porte separate per i registri di controllo
	- ![[Pasted image 20240113104910.png]]
	- DMA
		- Controllore DMA, con accesso diretto alla memoria
		- Accede ai bus indipendentemente dalla CPU
		- Ha molti registri
			- Di memoria
			- Di conteggio byte
			- Di controllo
		- ![[Pasted image 20240113105444.png]]
		- ![[Pasted image 20240113105459.png]]
		- ![[Pasted image 20240113105546.png]]
		- ![[Pasted image 20240113105538.png]]
		- ![[Pasted image 20240113105555.png]]
		- ![[Pasted image 20240113105605.png]]
		- ![[Pasted image 20240113105611.png]]
		- ![[Pasted image 20240113105619.png]]
		- ![[Pasted image 20240113105644.png]]
- **Obbiettivi software per I/O**
	- Affidabilità, correzione errori, gestiti preferibilmente hardware
	- Tipi di trasferimento
		- Sincrono (bloccanti)
		- Asincrono (interrupt)
	- Gestione buffer per trasferimento dei dati
		- Per prestazioni
	- Condivisione dei dati
- Metodi di gestione software dell’I/O 
	- I/O programmato 
		- delega alla CPU il controllo dell’operazione 
		- busy waiting della CPU semplice, ma potenzialmente inefficiente 
		- ![[Pasted image 20240113110100.png]]
		- ![[Pasted image 20240113110105.png]]
	- I/O guidato dal’interrput 
		- la CPU può eseguire altri processi mentre un processo è bloccato
		- uso di interrupt 
		- maggior utilizzazione della CPU, ma molti interrupt 
		- ![[Pasted image 20240113110115.png]]
	- I/O su DMA 
		- il controllore DMA, indipendente dalla CPU, interagisce con il dispositivo 
		- uso di hadware speciale, ma maggior concorrenza e utilizzo
		- ![[Pasted image 20240113110123.png]]
- **Elaborazione di un interrupt per I/O**
	- Salvataggio dei registri non ancora salvati dall’hardware (es PSW)
	- Caricamento contesto per la procedura di gestione dell’interrupt
	- Impostazione stack 
	- Avviso al controllore degli interrupt (o riabilitazione interrupt) 
	- Copia dei registri salvati nella tabella dei processi 
	- Esecuzione della procedura di gestione dell’interrupt, che recupera le informazioni dai registri del controllore del dispositivo 
	- Scelta del prossimo processo da eseguire 
	- Impostazione del contesto della MMU per il prossimo processo, eventualmente anche della TLB 
	- Caricamento dei nuovi registri del processo, compreso PSW 
	- Avvio dell’esecuzione del nuovo processo

[[Memoria secondaria e RAID]]
